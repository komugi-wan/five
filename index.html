<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Dusty Note - カード型メモアプリ</title>
  
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>

  <style>
    /* ==========================================================================
       1. CSS Variables & Theme (テーマ設定・くすみピンク)
       ========================================================================== */
    :root {
      /* Theme Colors */
      --color-primary: #D1B3B9;       /* くすみピンク */
      --color-primary-dark: #B5939A;  /* やや濃いくすみピンク */
      --color-primary-light: #F2E9EA; /* 薄いくすみピンク（背景アクセント） */
      --color-bg: #FAF8F8;            /* アプリのベース背景色 */
      --color-surface: #FFFFFF;       /* カードなどの表面色 */
      --color-text-main: #4A4546;     /* メインテキスト（真っ黒を避けて視認性向上） */
      --color-text-sub: #8C8486;      /* サブテキスト */
      --color-border: #E8DFE1;        /* 境界線 */
      
      /* Typography */
      --font-family: 'Helvetica Neue', Arial, 'Hiragino Kaku Gothic ProN', 'Hiragino Sans', Meiryo, sans-serif;
      
      /* UI Specs */
      --border-radius-lg: 16px;
      --border-radius-md: 12px;
      --border-radius-sm: 8px;
      --shadow-sm: 0 2px 8px rgba(0,0,0,0.04);
      --shadow-md: 0 4px 16px rgba(0,0,0,0.08);
      
      /* Spacing & Layout */
      --safe-area-top: env(safe-area-inset-top, 0px);
      --safe-area-bottom: env(safe-area-inset-bottom, 0px);
      --header-height: 60px;
    }

    /* ==========================================================================
       2. Reset & Base Styles
       ========================================================================== */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: var(--font-family);
      background-color: var(--color-bg);
      color: var(--color-text-main);
      -webkit-font-smoothing: antialiased;
      overflow: hidden; /* ビューのスクロールは内部で制御 */
      user-select: none; /* スマホでの不要なテキスト選択を防止 */
    }

    input, textarea, button {
      font-family: inherit;
      color: inherit;
      border: none;
      outline: none;
      background: none;
      user-select: auto;
    }

    /* ==========================================================================
       3. Layout & Views (SPA風の画面切り替え)
       ========================================================================== */
    #app-container {
      width: 100vw;
      height: 100vh;
      position: relative;
    }

    .view {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: flex;
      flex-direction: column;
      background-color: var(--color-bg);
      transform: translateX(100%);
      transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
      z-index: 1;
    }

    .view.active {
      transform: translateX(0);
      z-index: 10;
    }

    .header {
      padding: calc(var(--safe-area-top) + 12px) 16px 12px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background-color: var(--color-bg);
      border-bottom: 1px solid var(--color-border);
      height: calc(var(--header-height) + var(--safe-area-top));
      flex-shrink: 0;
    }

    .header h1 {
      font-size: 20px;
      font-weight: 700;
      color: var(--color-primary-dark);
    }

    .scroll-area {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      padding-bottom: calc(var(--safe-area-bottom) + 80px); /* FAB用の余白 */
    }

    /* ==========================================================================
       4. Components (Tags, Cards, Buttons, Editor)
       ========================================================================== */
    /* Tags Container (Horizontal Scroll) */
    .tags-bar {
      display: flex;
      gap: 8px;
      padding: 12px 16px;
      overflow-x: auto;
      background-color: var(--color-bg);
      border-bottom: 1px solid var(--color-border);
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
    .tags-bar::-webkit-scrollbar { display: none; }

    .tag-chip {
      padding: 6px 14px;
      border-radius: 20px;
      background-color: var(--color-surface);
      border: 1px solid var(--color-border);
      font-size: 13px;
      color: var(--color-text-sub);
      white-space: nowrap;
      cursor: pointer;
      transition: all 0.2s;
    }
    .tag-chip.active {
      background-color: var(--color-primary);
      color: white;
      border-color: var(--color-primary);
    }

    /* Memo Grid (Home) */
    .memo-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
      grid-auto-rows: minmax(160px, auto); 
    }

    /* Memo Card */
    .card {
      background-color: var(--color-surface);
      border-radius: var(--border-radius-md);
      padding: 14px;
      box-shadow: var(--shadow-sm);
      display: flex;
      flex-direction: column;
      cursor: pointer;
      transition: box-shadow 0.2s;
      position: relative;
    }
    .card:active { box-shadow: none; transform: scale(0.98); }
    
    .card-title {
      font-size: 15px;
      font-weight: bold;
      margin-bottom: 6px;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    
    .card-content {
      font-size: 13px;
      color: var(--color-text-sub);
      line-height: 1.5;
      flex: 1;
      display: -webkit-box;
      -webkit-line-clamp: 4;
      -webkit-box-orient: vertical;
      overflow: hidden;
      margin-bottom: 12px;
    }

    .card-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: auto;
    }

    .card-tags {
      font-size: 11px;
      color: var(--color-primary-dark);
      background-color: var(--color-primary-light);
      padding: 2px 6px;
      border-radius: 4px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 70%;
    }

    .thread-indicator {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 12px;
      color: var(--color-text-sub);
    }

    /* Editor Card (Thread View) */
    .editor-list {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .editor-card {
      background-color: var(--color-surface);
      border-radius: var(--border-radius-md);
      padding: 16px;
      box-shadow: var(--shadow-sm);
      position: relative;
      transition: all 0.3s ease;
    }
    /* スレッド連結の視覚的表現 */
    .editor-card:not(:first-child)::before {
      content: '';
      position: absolute;
      top: -16px;
      left: 32px;
      width: 2px;
      height: 16px;
      background-color: var(--color-primary);
    }

    /* 折りたたみ用スタイル */
    .editor-card.collapsed {
      padding: 12px 16px;
    }
    .editor-card.collapsed .editor-full-view { display: none; }
    .editor-card:not(.collapsed) .editor-collapsed-view { display: none; }

    .collapsed-preview {
      display: flex;
      flex-direction: column;
      gap: 4px;
      cursor: pointer;
    }
    .collapsed-title { font-weight: bold; font-size: 15px; color: var(--color-text-main); }
    .collapsed-text { font-size: 12px; color: var(--color-text-sub); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

    .editor-input {
      width: 100%;
      background: transparent;
      margin-bottom: 8px;
    }
    .editor-title {
      font-size: 18px;
      font-weight: bold;
      color: var(--color-text-main);
      padding-right: 30px; /* アイコン用 */
    }
    .editor-title::placeholder { color: #ccc; }
    
    .editor-content {
      font-size: 15px;
      line-height: 1.6;
      resize: none;
      min-height: 80px;
    }
    
    .editor-tags-input {
      font-size: 13px;
      color: var(--color-primary-dark);
      border-top: 1px dashed var(--color-border);
      padding-top: 8px;
    }

    .editor-actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 8px;
    }

    .btn-delete {
      color: #ff6b6b;
      font-size: 12px;
      padding: 4px 8px;
    }

    .btn-toggle-view {
      padding: 4px;
      color: var(--color-text-sub);
      cursor: pointer;
    }

    /* Floating Action Button */
    .fab {
      position: absolute;
      bottom: calc(var(--safe-area-bottom) + 24px);
      right: 24px;
      width: 56px;
      height: 56px;
      border-radius: 28px;
      background-color: var(--color-primary);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: var(--shadow-md);
      cursor: pointer;
      z-index: 100;
      transition: transform 0.2s;
    }
    .fab:active { transform: scale(0.9); }

    .btn-icon {
      width: 40px; height: 40px;
      display: flex; align-items: center; justify-content: center;
      border-radius: 50%;
      cursor: pointer;
    }
    .btn-icon:active { background-color: rgba(0,0,0,0.05); }

    /* Utilities */
    .sortable-ghost { opacity: 0.4; }
    .sortable-drag { background-color: var(--color-primary-light); cursor: grabbing !important; }
    .drag-handle { padding: 8px; margin: -8px; color: var(--color-border); }

  </style>
</head>
<body>

  <div id="app-container">
    
    <div id="view-home" class="view active">
      <header class="header">
        <h1>Dusty Note</h1>
      </header>
      
      <div class="tags-bar" id="home-tags-bar"></div>

      <div class="scroll-area">
        <div class="memo-grid" id="home-memo-grid"></div>
      </div>

      <button class="fab" id="btn-add-memo">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg>
      </button>
    </div>

    <div id="view-thread" class="view">
      <header class="header">
        <button class="btn-icon" id="btn-back">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="var(--color-text-main)" stroke-width="2"><path d="M19 12H5M12 19l-7-7 7-7"/></svg>
        </button>
        <h1 style="font-size: 16px;">スレッド編集</h1>
        <div style="width: 40px;"></div>
      </header>

      <div class="scroll-area" id="thread-scroll-area">
        <div class="editor-list" id="thread-editor-list"></div>
        
        <button class="fab" id="btn-add-thread" style="background-color: var(--color-primary-dark);">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg>
        </button>
      </div>
    </div>

  </div>

  <script>
    /**
     * ==========================================================================
     * 1. Data Layer (IndexedDB Wrapper)
     * ==========================================================================
     */
    class MemoDatabase {
      constructor() {
        this.dbName = 'DustyNoteDB';
        this.dbVersion = 1;
        this.storeName = 'memos';
        this.db = null;
      }

      async init() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(this.dbName, this.dbVersion);
          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(this.storeName)) {
              const store = db.createObjectStore(this.storeName, { keyPath: 'id' });
              store.createIndex('parentId', 'parentId', { unique: false });
              store.createIndex('order', 'order', { unique: false });
            }
          };
          request.onsuccess = (event) => {
            this.db = event.target.result;
            resolve();
          };
          request.onerror = (event) => reject(event.target.error);
        });
      }

      async getAll() {
        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([this.storeName], 'readonly');
          const store = transaction.objectStore(this.storeName);
          const request = store.getAll();
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });
      }

      async save(memo) {
        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([this.storeName], 'readwrite');
          const store = transaction.objectStore(this.storeName);
          memo.updatedAt = Date.now();
          const request = store.put(memo);
          request.onsuccess = () => resolve();
          request.onerror = () => reject(request.error);
        });
      }

      async delete(id) {
        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([this.storeName], 'readwrite');
          const store = transaction.objectStore(this.storeName);
          const request = store.delete(id);
          request.onsuccess = () => resolve();
          request.onerror = () => reject(request.error);
        });
      }

      async updateOrders(orderUpdates) {
        const transaction = this.db.transaction([this.storeName], 'readwrite');
        const store = transaction.objectStore(this.storeName);
        orderUpdates.forEach(update => {
          const getReq = store.get(update.id);
          getReq.onsuccess = () => {
            const data = getReq.result;
            if (data) {
              data.order = update.order;
              store.put(data);
            }
          };
        });
        return new Promise((resolve) => {
          transaction.oncomplete = () => resolve();
        });
      }
    }

    /**
     * ==========================================================================
     * 2. Application State & Logic
     * ==========================================================================
     */
    class AppLogic {
      constructor(db) {
        this.db = db;
        this.memos = [];
        this.currentTagFilter = null;
        this.currentParentId = null;
      }

      async loadData() {
        this.memos = await this.db.getAll();
        this.memos.sort((a, b) => a.order - b.order || b.createdAt - a.createdAt);
      }

      createMemoObject(parentId = null) {
        return {
          id: 'memo_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
          parentId: parentId,
          title: '',
          content: '',
          tags: [],
          order: Date.now(),
          createdAt: Date.now(),
          updatedAt: Date.now()
        };
      }

      getHomeMemos() {
        let parents = this.memos.filter(m => m.parentId === null);
        if (this.currentTagFilter) {
          parents = parents.filter(m => m.tags.includes(this.currentTagFilter));
        }
        return parents;
      }

      getThreadMemos(parentId) {
        const parent = this.memos.find(m => m.id === parentId);
        const children = this.memos.filter(m => m.parentId === parentId);
        children.sort((a, b) => a.order - b.order || a.createdAt - b.createdAt);
        return parent ? [parent, ...children] : [];
      }

      getThreadCount(parentId) {
        return this.memos.filter(m => m.parentId === parentId).length;
      }

      getAllTags() {
        const tagSet = new Set();
        this.memos.filter(m => m.parentId === null).forEach(m => {
          m.tags.forEach(t => tagSet.add(t));
        });
        return Array.from(tagSet).sort();
      }

      async saveMemo(memoData) {
        await this.db.save(memoData);
        await this.loadData();
      }

      async deleteMemoAndThread(id) {
        const children = this.memos.filter(m => m.parentId === id);
        for (const child of children) {
          await this.db.delete(child.id);
        }
        await this.db.delete(id);
        await this.loadData();
      }
    }

    /**
     * ==========================================================================
     * 3. UI Manager
     * ==========================================================================
     */
    class UIManager {
      constructor(appLogic) {
        this.app = appLogic;
        
        this.viewHome = document.getElementById('view-home');
        this.viewThread = document.getElementById('view-thread');
        this.memoGrid = document.getElementById('home-memo-grid');
        this.tagsBar = document.getElementById('home-tags-bar');
        this.editorList = document.getElementById('thread-editor-list');
        
        this.homeSortable = null;
        this.threadSortable = null;

        this.initEventListeners();
      }

      initEventListeners() {
        document.getElementById('btn-add-memo').addEventListener('click', () => this.createNewMemoAndOpen());
        document.getElementById('btn-back').addEventListener('click', () => this.navigate('home'));
        document.getElementById('btn-add-thread').addEventListener('click', () => this.createNewThreadMemo());
        this.saveTimeout = null;
      }

      navigate(viewName) {
        if (viewName === 'home') {
          this.viewThread.classList.remove('active');
          this.viewHome.classList.add('active');
          this.app.currentParentId = null;
          this.renderHome();
        } else if (viewName === 'thread') {
          this.viewHome.classList.remove('active');
          this.viewThread.classList.add('active');
          this.renderThread();
        }
      }

      renderHome() {
        this.renderTags();
        this.renderGrid();
        this.initHomeSortable();
      }

      renderTags() {
        const tags = this.app.getAllTags();
        this.tagsBar.innerHTML = '';
        
        const allChip = document.createElement('div');
        allChip.className = `tag-chip ${this.app.currentTagFilter === null ? 'active' : ''}`;
        allChip.textContent = 'すべて';
        allChip.addEventListener('click', () => {
          this.app.currentTagFilter = null;
          this.renderHome();
        });
        this.tagsBar.appendChild(allChip);

        tags.forEach(tag => {
          const chip = document.createElement('div');
          chip.className = `tag-chip ${this.app.currentTagFilter === tag ? 'active' : ''}`;
          chip.textContent = tag;
          chip.addEventListener('click', () => {
            this.app.currentTagFilter = tag;
            this.renderHome();
          });
          this.tagsBar.appendChild(chip);
        });
      }

      renderGrid() {
        const memos = this.app.getHomeMemos();
        this.memoGrid.innerHTML = '';
        
        memos.forEach(memo => {
          const threadCount = this.app.getThreadCount(memo.id);
          const card = document.createElement('div');
          card.className = 'card';
          card.dataset.id = memo.id;
          
          const tagsHtml = memo.tags.length > 0 
            ? `<div class="card-tags">${this.escapeHTML(memo.tags.join(', '))}</div>` 
            : `<div></div>`;

          const threadHtml = threadCount > 0 ? `
            <div class="thread-indicator">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>
              ${threadCount}
            </div>
          ` : '';

          card.innerHTML = `
            <div class="card-title">${this.escapeHTML(memo.title) || '無題のメモ'}</div>
            <div class="card-content">${this.escapeHTML(memo.content).replace(/\n/g, '<br>') || 'タップして編集...'}</div>
            <div class="card-footer">
              ${tagsHtml}
              ${threadHtml}
            </div>
          `;

          card.addEventListener('click', () => {
            this.app.currentParentId = memo.id;
            this.navigate('thread');
          });

          this.memoGrid.appendChild(card);
        });
      }

      initHomeSortable() {
        if (this.homeSortable) this.homeSortable.destroy();
        this.homeSortable = new Sortable(this.memoGrid, {
          animation: 200,
          delay: 200,
          delayOnTouchOnly: true,
          ghostClass: 'sortable-ghost',
          dragClass: 'sortable-drag',
          onEnd: async (evt) => {
            const itemEls = Array.from(this.memoGrid.children);
            const updates = itemEls.map((el, index) => ({
              id: el.dataset.id,
              order: index
            }));
            await this.app.db.updateOrders(updates);
            await this.app.loadData();
          }
        });
      }

      async createNewMemoAndOpen() {
        const newMemo = this.app.createMemoObject();
        await this.app.saveMemo(newMemo);
        this.app.currentParentId = newMemo.id;
        this.navigate('thread');
      }

      async createNewThreadMemo() {
        if (!this.app.currentParentId) return;
        const childMemo = this.app.createMemoObject(this.app.currentParentId);
        await this.app.saveMemo(childMemo);
        this.renderThread();
        setTimeout(() => {
          const scrollArea = document.getElementById('thread-scroll-area');
          scrollArea.scrollTop = scrollArea.scrollHeight;
        }, 100);
      }

      renderThread() {
        const memos = this.app.getThreadMemos(this.app.currentParentId);
        this.editorList.innerHTML = '';

        memos.forEach((memo, index) => {
          const isParent = memo.parentId === null;
          const editorCard = document.createElement('div');
          editorCard.className = 'editor-card';
          // 新規作成時（中身が空）以外は最初は閉じて表示する
          if (memo.title !== '' || memo.content !== '') {
            editorCard.classList.add('collapsed');
          }
          editorCard.dataset.id = memo.id;

          editorCard.innerHTML = `
            <div class="editor-collapsed-view">
              <div class="collapsed-preview">
                <div class="collapsed-title">${this.escapeHTML(memo.title) || (isParent ? 'メインタイトル' : 'スレッドタイトル')}</div>
                <div class="collapsed-text">${this.escapeHTML(memo.content) || 'テキストなし'}</div>
              </div>
            </div>

            <div class="editor-full-view">
              <div style="display:flex; justify-content:space-between;">
                <input type="text" class="editor-input editor-title" value="${this.escapeHTML(memo.title)}" placeholder="${isParent ? 'メインタイトル' : 'スレッドタイトル'}">
                <div class="drag-handle">
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line></svg>
                </div>
              </div>
              <textarea class="editor-input editor-content" placeholder="テキストを入力...">${this.escapeHTML(memo.content)}</textarea>
              <input type="text" class="editor-input editor-tags-input" value="${this.escapeHTML(memo.tags.join(' '))} " placeholder="タグをスペース区切りで入力">
              
              <div class="editor-actions">
                <button class="btn-delete" data-id="${memo.id}">削除</button>
              </div>
            </div>

            <div class="btn-toggle-view" style="position:absolute; top:12px; right:40px;">
                <svg class="icon-chevron" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="transition: transform 0.3s;"><path d="M6 9l6 6 6-6"/></svg>
            </div>
          `;

          // 折りたたみ制御
          const toggleBtn = editorCard.querySelector('.btn-toggle-view');
          const collapsedView = editorCard.querySelector('.editor-collapsed-view');
          const chevron = editorCard.querySelector('.icon-chevron');
          
          const toggleCollapse = () => {
            const isCollapsed = editorCard.classList.toggle('collapsed');
            chevron.style.transform = isCollapsed ? 'rotate(0deg)' : 'rotate(180deg)';
            if (isCollapsed) {
              // 閉じるときに最新の入力をプレビューに反映
              editorCard.querySelector('.collapsed-title').textContent = editorCard.querySelector('.editor-title').value || (isParent ? 'メインタイトル' : 'スレッドタイトル');
              editorCard.querySelector('.collapsed-text').textContent = editorCard.querySelector('.editor-content').value || 'テキストなし';
            } else {
              // 開いたときに高さを再調整
              setTimeout(autoResize, 0);
            }
          };

          toggleBtn.addEventListener('click', toggleCollapse);
          collapsedView.addEventListener('click', toggleCollapse);
          if (!editorCard.classList.contains('collapsed')) chevron.style.transform = 'rotate(180deg)';

          // Auto Resize Textarea
          const textarea = editorCard.querySelector('.editor-content');
          const autoResize = () => {
            textarea.style.height = 'auto';
            textarea.style.height = textarea.scrollHeight + 'px';
          };
          textarea.addEventListener('input', autoResize);
          setTimeout(autoResize, 0);

          // Auto Save Logic
          const inputs = editorCard.querySelectorAll('input, textarea');
          inputs.forEach(input => {
            input.addEventListener('input', () => this.debouncedSave(editorCard, memo));
            input.addEventListener('blur', () => this.forceSave(editorCard, memo));
          });

          // Delete Logic
          editorCard.querySelector('.btn-delete').addEventListener('click', async () => {
            if (confirm('このメモを削除しますか？\n（親メモの場合は連なるスレッドも全て削除されます）')) {
              await this.app.deleteMemoAndThread(memo.id);
              if (isParent) {
                this.navigate('home');
              } else {
                this.renderThread();
              }
            }
          });

          this.editorList.appendChild(editorCard);
        });

        this.initThreadSortable();
      }

      initThreadSortable() {
        if (this.threadSortable) this.threadSortable.destroy();
        this.threadSortable = new Sortable(this.editorList, {
          handle: '.drag-handle',
          animation: 200,
          ghostClass: 'sortable-ghost',
          onEnd: async (evt) => {
            const itemEls = Array.from(this.editorList.children);
            const updates = itemEls.map((el, index) => ({
              id: el.dataset.id,
              order: index
            }));
            await this.app.db.updateOrders(updates);
            await this.app.loadData();
          }
        });
      }

      async forceSave(cardElement, originalMemo) {
        clearTimeout(this.saveTimeout);
        const title = cardElement.querySelector('.editor-title').value.trim();
        const content = cardElement.querySelector('.editor-content').value.trim();
        const tagsStr = cardElement.querySelector('.editor-tags-input').value.trim();
        const tags = tagsStr ? tagsStr.split(/\s+/).filter(t => t) : [];

        if (title === originalMemo.title && content === originalMemo.content && JSON.stringify(tags) === JSON.stringify(originalMemo.tags)) {
          return;
        }

        const updatedMemo = { ...originalMemo, title, content, tags };
        await this.app.saveMemo(updatedMemo);
      }

      debouncedSave(cardElement, originalMemo) {
        clearTimeout(this.saveTimeout);
        this.saveTimeout = setTimeout(() => {
          this.forceSave(cardElement, originalMemo);
        }, 1000);
      }

      escapeHTML(str) {
        if (!str) return '';
        return str.replace(/[&<>'"]/g, tag => ({
          '&': '&amp;', '<': '&lt;', '>': '&gt;', "'": '&#39;', '"': '&quot;'
        }[tag]));
      }
    }

    /**
     * ==========================================================================
     * 4. Initialization
     * ==========================================================================
     */
    document.addEventListener('DOMContentLoaded', async () => {
      const db = new MemoDatabase();
      try {
        await db.init();
        const appLogic = new AppLogic(db);
        await appLogic.loadData();
        const uiManager = new UIManager(appLogic);
        uiManager.renderHome();
      } catch (error) {
        console.error("アプリの初期化に失敗しました:", error);
        alert("データベースの初期化に失敗しました。");
      }
    });
  </script>
</body>
</html>
